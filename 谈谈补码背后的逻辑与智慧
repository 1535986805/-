在计算机的存储中数据通过二进制补码的方式储存，正数的补码与其原码相同，而负数则大不相同。负数的补码需要在原码的基础上进行一番“七十二变”才可以得到其补码。
例如5在二进制中被表示为0101，这就是5的原码表示。其中101表示储存的这个数的大小，而最高位的0表示的便是这个数的符号，最高位也往往被称作符号位。若符号位为0，则表示该数为正数；若符号位为1，则表示该数为负数。-5的原码就呼之欲出了：1101。

上图是1、2、-1、-2的原码示意图，其中黑色的表示数的大小，最高位的符号位则是用红色标明的数字。很明显可以看出上文中所提到的：若符号位为0，则表示该数为正数；若符号位为1，则表示该数为负数。
既然知道了负数的原码怎么表示，那原码怎么转变为补码呢？笔者认为下图可以清晰地解答我们心中的疑惑。

上图为-1原码转补码的示意图。在保持符号位不变的情况下，将负数的原码取反，即0变为1、1变为0得到该负数的反码，然后再将反码+1得到该负数的补码。这就是-1在计算机中存储的样式。

补码的由来
一道人类需要计算许久的数学运算也许计算机能够瞬间得出答案，这就归功于计算机的运算器。但是CPU中只有加法运算器，并没有其他的像减法运算器之类的运算器。在数学运算中有着加减乘除等众多运算，如果只有加法运算器是如何来进行庞大的数学计算的呢？
众所周知，在数学运算中，无论是减法还是乘除法都可以转化为加法运算。比如5－3＝2，这个运算式等价于5＋（－3）＝2，于是减法便能够转化为加法。乘法在学习初期便被给予了一种从加法的角度看待乘法的方式，如2*3可以看作是2个3相加，或是3个2相加。而除法可转化为乘法。这样这些运算便可以都通过加法的方式进行计算。
那么由于只有加法计算器，减法便需要借助补码这个媒介来转化为加法。于是在1954，美国贝尔实验室（Belt Labs）的研究员约翰·汉明（John von Neumann）首次提出补码这一想法。
在探索初期，补码的思想源自于生活中一个极其常见的事物：时钟。

上图是一个普通的时钟。假若你此时需要校准该时钟，想要将时钟由10点调为9点，这个时候你将有两个选择：
1、将时针逆时针旋转1小时，即10-1=9；
2、将时针顺时针旋转11小时，即10+11=9。
这两种的校准方式是极其易于了解的，但第2种中的“10+11=9”是为什么呢？在我们的认知中10+11=21才是正确的，如果将24小时制的时间转化为12小时制的时间，在12小时制中21点产生了溢出，所以21点与9点是等价的，于是这就有了第2种。
这便是补码的思想来源。
在此后的几十年中，补码逐渐被各个制造商采用，成为大多数计算机体系结构中默认的有符号整数表示方法。经过几十年的发展，补码终于以我们熟知的面貌来到了我们面前，成为了计算机中不可或缺的一部分。

4、补码的其他意义
那么补码存在的意义和智慧只有将运算转化为加法吗？大错特错，笔者认为还有以下意义：

4.1、统一0的表示
在存储中用原码表示正数，用补码表示负数不仅可以简化运算，还统一了0的表示。
对于双字节整型数而言：

00000000 00000000 表示+0的原码和补码
10000000 00000000 表示-0的原码
11111111 11111111 表示-0的反码
00000000 00000000 表示-0的补码
1
2
3
4
显然，对于原码而言，+0与-0的表示是不同的，但+0与-0在数学中是表示的同一个数。所以就需要补码来表示负数来统一0的表示。

4.2、便于处理溢出
在补码系统中，我们可以通过观察最高位的进位标志来检测运算是否发生了溢出，这使得程序可以更高效地处理大规模计算的溢出问题。

4.3、简化电路设计
性质决定其功能，补码将运算简化，这使得其在电路设计上也存在巨大的意义。
当两个数进行加法运算时，如果其中一个数是负数，直接在加法器中处理会变得复杂。补码的出现使得加法器可以统一处理正数和负数，从而简化了电路设计。
负数的最高位始终为1，这有助于电路在处理过程中更准确地识别和处理正数和负数,，从而减少了电路设计的错误的发生。


！【图片】（https://i-blog.csdnimg.cn/direct/cb89587ceb00462393f1de26817ada24.png#pic_center）
